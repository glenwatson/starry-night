<html>
	<head>
		<style>
			html, body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}
			body {
				background-color: #000000
			}
			canvas {
				position: absolute;
				left: 0;
				top: 0;
			}
			#settings {
				position: absolute;
				right: 0;
				bottom: 0;
			}
		</style>
	</head>
	<body>
		<canvas id="space">No canvas support</canvas>
		<div id="settings">
			<input onclick="DEBUG =! DEBUG;" type="checkbox" />
			<input onclick="CLEAR_ON_DRAW =! CLEAR_ON_DRAW;" type="checkbox" />
			<input onclick="forces=[];" type="checkbox" />
		</div>
		<script>
			var ANIMATION_FRAME = false;
			var SPEED = 1; // only used if ANIMATION_FRAME == false
			var NUM_STARS = 1000;
			var FORCE_DIST = 200;
			var DEBUG = true;
			var CLEAR_ON_DRAW = true;
			var canvas = document.getElementById('space');
			canvas.width = document.body.clientWidth;
			canvas.height = document.body.clientHeight;
			var ctx = canvas.getContext('2d');
			ctx.font = "8pt Arial";
			ctx.textAlign = "end";
			
			var stars = [];
			var hiddenStars = [];
			var forces = [];
			//populate
			for(var i=0; i<NUM_STARS; i++) {
				stars.push({
					pos: {
						x: Math.random() * canvas.width,
						y: Math.random() * canvas.height,
					},
					color: randomColor(),
					hidden: false,
				});
			}
			
			var mouseDownPoint={x:0, y:0};
			canvas.onmousedown = function (e) {
				mouseDownPoint = {x: e.clientX, y: e.clientY};
			}
			canvas.onmouseup = function (e) {
				forces.push({
					pos: mouseDownPoint, 
					vect: sub({x: e.clientX, y: e.clientY}, mouseDownPoint), 
					strength: 5
				});
			}
			
			//start
			start();
			
			function start() {
				if (ANIMATION_FRAME && window.requestAnimationFrame) {
					tick();
				} else {
					ANIMATION_FRAME = false;
					setInterval(tick, SPEED);
				}
			}
			function tick() {
				moveStars(stars);
				if (CLEAR_ON_DRAW) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
				drawStars(stars);
				if (DEBUG) {
					drawForces(forces);
					drawFramerate();
					drawFps();
				}
				if (ANIMATION_FRAME) {
					requestAnimationFrame(tick);
				}
				while(s = hiddenStars.shift()) {
					stars[s].pos = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
					stars[s].hidden = false;
				}
			}
			var fps = 0;
			var frameCount = 0;
			function drawFps() {
				frameCount++;
				ctx.fillStyle = "#ffffff";
				ctx.fillText(fps+" fps", canvas.width-10, 20);
			}
			setInterval(function() {
				fps = frameCount;
				frameCount = 0;
			}, 1000);
			
			var lastFrame = new Date().getTime();
			function drawFramerate() {
				var thisFrame = new Date().getTime();
				ctx.fillStyle = "#ffffff";
				ctx.fillText((thisFrame - lastFrame) / 1000, canvas.width-10, 10);
				lastFrame = thisFrame;
			}
			function dist(pos1, pos2) {
				return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
			}
			function drawStars(stars) {
				for(var i in stars) {
					if (!stars[i].hidden) {
						if (isOutsideScreen(stars[i])) {
							stars[i].hidden = true;
							hiddenStars.push(i);
						} else {
							ctx.fillStyle = stars[i].color;
							drawStar(stars[i].pos.x, stars[i].pos.y, ctx);
						}
					}
				}
			}
			function drawStar(x, y, ctx) {
				ctx.beginPath();
				ctx.arc(x, y, 2, 0, Math.PI*2, true);
				ctx.fill();
				ctx.closePath();
			}
			function drawForces(forces) {
				ctx.strokeStyle = "#ffffff";
				for(var i in forces) {
					drawForce(forces[i], ctx);
				}
			}
			function drawForce(force, ctx) {
				ctx.lineWidth = force.strength/5;
				ctx.beginPath();
				ctx.moveTo(force.pos.x, force.pos.y);
				ctx.lineTo(force.pos.x+force.vect.x, force.pos.y+force.vect.y);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(force.pos.x+force.vect.x, force.pos.y+force.vect.y, force.strength*2, 0, Math.PI*2, true);
				ctx.stroke();
			}
			function randomColor() {
				return "#"+randomHex()+randomHex()+randomHex()+randomHex()+randomHex()+randomHex();
			}
			function randomHex() {
				return Math.round(Math.random() * 16).toString(16);
			}
			function isOutsideScreen(star) {
				return star.pos.x < 0 || star.pos.y < 0 ||
					star.pos.x > canvas.width || star.pos.y > canvas.height;
			}
			// ==Movement==
			function moveStars(stars) {
					for (var f in forces) {
					var force = forces[f];
					var forceEnd = add(force.pos, force.vect);
					for(var i in stars) {
						var star = stars[i];
						var d = distPointToSegment(star.pos, force.pos, forceEnd);
						if (d < FORCE_DIST) {
							var pull = force.strength * (FORCE_DIST - d) / FORCE_DIST;
							if (force.vect.x) {
								star.pos.x += pull * force.vect.x / Math.abs(force.vect.x);
							}
							if (force.vect.y) {
								star.pos.y += pull * force.vect.y / Math.abs(force.vect.y);
							}
						}
					}
				}
			}
			// http://geomalgorithms.com/a02-_lines.html
			function distPointToSegment(point, segStart, segEnd) {
				var v = sub(segEnd, segStart);
				var w = sub(point, segStart);
				var c1 = dot(w,v);
				if (c1 <= 0) {
					return vDist(point, segStart);
				}
				var c2 = dot(v,v);
				if (c2 <= c1) {
					return vDist(point, segEnd);
				}
				var b = c1 / c2;
				var pointB = add(segStart, vMulScalar(b, v));
				return vDist(point, pointB);
			}
			// =Helper functions=
			function dot(a, b) {
				return a.x * b.x + a.y * b.y;
			}
			function norm(v) {
				return Math.sqrt(dot(v,v));
			}
			function vDist(p1, p2) {
				return norm(sub(p1, p2));
			}
			function add(a, b) {
				return {x: a.x + b.x, y: a.y + b.y};
			}
			function sub(a, b) {
				return {x: a.x - b.x, y: a.y - b.y};
			}
			function vMulScalar(s, v) {
				return {x: v.x * s, y: v.y * s};
			}
		</script>
	</body>
</html>
