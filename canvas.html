<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
		<title>Stars</title>
		<link href='http://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
		<script type="text/javascript" src="js/rison.js" ></script>
		<style>
			html, body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}
			body {
				font-family: 'Montserrat', sans-serif;
				font-size: 22px;
				background-color: #000;
			}
			canvas {
				position: absolute;
				left: 0;
				top: 0;
			}
			
			#options {
				position: absolute;
				left: 0;
				bottom: 0;
				margin: 5px;
				width: 15px;
				height: 15px;
			}
			#optionsPanel {
				position: relative;
				margin-left: auto;
				margin-right: auto;
				margin-top: 20%;
				padding: 60px;
				width: 500px;
				height: 40%;
				color: #fff;
				background-color: #111;
				-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=90)";	/* IE 8 */
				filter: alpha(opacity=90);	/* IE 5-7 */
				-moz-opacity: 0.9;			/* Netscape */
				-khtml-opacity: 0.9;		/* Safari 1.x */
				opacity: 0.9;				/* Good browsers */
				border-radius: 25px;
			}
			.optionsRow {
				height: 40px;
			}
			.optionsCell {
				float: left;
				width: 100px;
			}
			#optionsContainer {
				width: 200px;
			}
			#optionsClose {
				position: absolute;
				top: 15;
				right: 15;
				cursor: pointer;
			}
			button {
				font-family: 'Montserrat', sans-serif;
				font-size: 22px;
				padding: 5px 10px;
				background-color: #444;
				color: #fff;
				border: 0;
				cursor: pointer;
			}
			button:hover {
				background-color: #666;
			}
			button:active {
				background-color: #222;
			}
		</style>
	</head>
	<body>
		<canvas id="space">No canvas support</canvas>
		<img id="options" onmouseover="showOptions();" src="img/gear512.png" />
		<div id="optionsPanel" style="display:none;" >
			<div id="optionsContainer" >
				<div class="optionsRow">
					<div class="optionsCell">Redraw</div>
					<div class="optionsCell"><input id="redraw" onclick="CLEAR_ON_DRAW =! CLEAR_ON_DRAW;" type="checkbox" checked="checked" /></div>
				</div>
				<div class="optionsRow">
					<div class="optionsCell">Debug</div>
					<div class="optionsCell"><input id="debug" onclick="DEBUG =! DEBUG;" type="checkbox" /></div>
				</div>
				<div class="optionsRow">
					<div class="optionsCell">Strength</div>
					<div class="optionsCell"><input id="strength" onclick=";" type="text" value="5" size="1" /></div>
				</div>
				<div class="optionsRow">
					<div class="optionsCell"><button onclick="forces=[];">Clear</button></div>
				</div>
				<div class="optionsRow">
					<div class="optionsCell"><button onclick="refreshUrl();">Save as URL</button></div>
				</div>
			</div>
			<div id="optionsClose" onclick="hideOptions();" >X</div>
		</div>
		<script>
			// =settings=
			var ANIMATION_FRAME = true;
			var SPEED = 1; // only used if ANIMATION_FRAME == false
			var NUM_STARS = 1000;
			var FORCE_DIST = 40;
			var DEBUG = document.getElementById('debug').checked;
			var CLEAR_ON_DRAW = document.getElementById('redraw').checked;
			// =template methods=
			var noop = function(){};
			var handleOffScreen = randomFadeIn; //randomizePos; //wrap;
			var getInitPos = resetOrigPos; //xSpreadPos; //randomPos;
			var getInitColor = randomColor; //rainbowColor;
			var recolor = recolorPos;
			var moveStars = moveStart; //moveLength;
			
			var canvas = document.getElementById('space');
			canvas.width = document.body.clientWidth;
			canvas.height = document.body.clientHeight;
			var ctx = canvas.getContext('2d');
			ctx.font = "8pt Arial";
			ctx.textAlign = "end";
			
			var stars = [];
			var forces = [];
			loadUrl();
			
			//populate
			for (var i=0; i<NUM_STARS; i++) {
				var star = {};
				star.pos = getInitPos(i, NUM_STARS);
				star.color = getInitColor(i, NUM_STARS, star);
				stars.push(star);
			}
			// =state persistence=
			function refreshUrl() {
				location.hash = '#' + rison.encode({'forces': forces});
			}
			function loadUrl() {
				var strState = location.hash;
				if (strState.length > 1) {
					// remove #
					strState = strState.substring(1, strState.length);
					// if the browser uri encoded it before copy, decode it (I'm looking at you firefox)
					if (strState[0] == '%') {
						strState = decodeURIComponent(strState);
					}
					state = rison.decode(strState);
					if (state.forces) {
						forces = state.forces;
					}
				}
			}
			
			// ==events==
			// =mouse clicks=
			;(function() {
				var mouseDownPoint={x:0, y:0};
				canvas.onmousedown = function (e) {
					if (e.which == 1) {
						mouseDownPoint = {x: e.clientX, y: e.clientY};
					}
				};
				canvas.onmouseup = function (e) {
					if (e.which == 1) {
						var strength = parseInt(document.getElementById('strength').value);
						if (isNaN(strength)) {
							strength = 5;
						}
						var mouseUpPoint = {x: e.clientX, y: e.clientY};
						if (!eq(mouseDownPoint, mouseUpPoint)) {
							forces.push({
								pos: mouseDownPoint, 
								vect: sub(mouseUpPoint, mouseDownPoint), 
								strength: strength
							});
						}
					}
				};
			})();
			// =keyboard events=
			;(function() {
				document.onkeypress = function(e) {
					e = e || window.event;
					//       escape: 13          enter: 27
					if (e.keyCode == 13 || e.keyCode == 27) {
						hideOptions();
					}
					//      plus(+): 43      equals(=): 61 (if they didn't hold shift)
					if (e.keyCode == 43 || e.keyCode == 61) {
						//increase strength
						var strength = parseInt(document.getElementById('strength').value);
						if (!isNaN(strength)) {
							document.getElementById('strength').value = strength+1;
						}
					}
					//     minus(-): 45
					if (e.keyCode == 45) {
						//decrease strength
						var strength = parseInt(document.getElementById('strength').value);
						if (!isNaN(strength) && strength > 1) {
							document.getElementById('strength').value = strength-1;
						}
					}
				};
			})();
			
			function showOptions() {
				document.getElementById('optionsPanel').style.display = 'block';
			}
			function hideOptions() {
				document.getElementById('optionsPanel').style.display = 'none';
			}
			
			function tick() {
				moveStars(stars, forces);
				if (recolor) {
					for (var i in stars) {
						stars[i].color = recolor(i, NUM_STARS, stars[i]);
					}
				}
				if (CLEAR_ON_DRAW) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
				drawStars(stars);
				if (DEBUG) {
					drawForces(forces);
					drawFramerate();
					drawFps();
				}
				if (ANIMATION_FRAME) {
					requestAnimationFrame(tick);
				}
			}
			
			// ==rendering==
			function drawStars(stars) {
				for (var i in stars) {
					ctx.fillStyle = stars[i].color;
					drawStar(stars[i].pos.x, stars[i].pos.y, ctx);
				}
			}
			function drawStar(x, y, ctx) {
				ctx.beginPath();
				ctx.arc(x, y, 2, 0, Math.PI*2, true);
				ctx.fill();
				ctx.closePath();
			}
			function drawForces(forces) {
				ctx.strokeStyle = "#ffffff";
				for (var i in forces) {
					drawForce(forces[i], ctx);
				}
			}
			function drawForce(force, ctx) {
				ctx.lineWidth = force.strength/5;
				ctx.beginPath();
				ctx.moveTo(force.pos.x, force.pos.y);
				ctx.lineTo(force.pos.x+force.vect.x, force.pos.y+force.vect.y);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(force.pos.x, force.pos.y, force.strength*FORCE_DIST, 0, Math.PI*2, true);
				ctx.stroke();
			}
			// =fps=
			var drawFps = (function() {
				var fps = 0;
				var frameCount = 0;
				setInterval(function() {
					fps = frameCount;
					frameCount = 0;
				}, 1000); //1 second
				return function() {
					frameCount++;
					ctx.fillStyle = "#ffffff";
					ctx.fillText(fps+" fps", canvas.width-10, 20);
				}
			})();
			
			// =framerate=
			var drawFramerate = (function() {
				var lastFrame = new Date().getTime();
				return function() {
					var thisFrame = new Date().getTime();
					ctx.fillStyle = "#ffffff";
					ctx.fillText((thisFrame - lastFrame) / 1000, canvas.width-10, 10);
					lastFrame = thisFrame;
				}
			})();
			// =pos=
			function randomPos() {
				return {
					x: Math.random() * canvas.width,
					y: Math.random() * canvas.height,
				};
			}
			function xSpreadPos(i, totalCount) {
				return {
					x: (i / totalCount) * canvas.width,
					y: Math.random() * canvas.height,
				};
			}
			function gridPos(i, totalCount) {
				var val = i / totalCount * canvas.width * canvas.height;
				return {
					x: val % canvas.width,
					y: val / canvas.height,
				};
			}
			function resetOrigPos() {
				var pos = randomPos();
				pos.xOrig = pos.x;
				pos.yOrig = pos.y;
				return pos;
			}
			// =color=
			function randomColor() {
				return "#"+Math.round(Math.random() * Math.pow(16, 6)).toString(16);
			}
			function rainbowColor(i, total) {
				return "hsl("+(i / total * 360)+", 100%, 50%)";
			}
			function recolorPos(i, total, star) {
				return "hsl("+huePos(star)+", 100%, "+lightnessSparkle(star)+"%)";
			}
			function huePos(star) {
				return star.pos.x / canvas.width * 360;
			}
			function lightnessSparkle(star) {
				var OSCILLATION_SPEED =  0.02;
				if (typeof star.brightness == 'undefined') {
					star.brightness = Math.random() * Math.PI;
				} else if (star.brightness > Math.PI) {
					star.brightness = 0;
					star.pos.x = star.pos.xOrig;
					star.pos.y = star.pos.yOrig;
				} else {
					star.brightness += OSCILLATION_SPEED;
				}
				return Math.round(Math.sin(star.brightness)*90);
			}
			function isOutsideScreen(star) {
				return star.pos.x < 0 || star.pos.y < 0 ||
					star.pos.x > canvas.width || star.pos.y > canvas.height;
			}
			// ==Movement==
			function moveLength(stars, forces) {
				for (var f in forces) {
					var force = forces[f];
					var forceEnd = add(force.pos, force.vect);
					for (var i in stars) {
						var star = stars[i];
						var d = distPointToSegment(star.pos, force.pos, forceEnd);
						var forceReach = force.strength * FORCE_DIST;
						if (d < forceReach) {
							var pull = force.strength * (forceReach - d) / forceReach;
							var magnitude = norm(force.vect);
							var unitVect = vMulScalar(1/magnitude, force.vect);
							if (force.vect.x) {
								star.pos.x += pull * unitVect.x;
							}
							if (force.vect.y) {
								star.pos.y += pull * unitVect.y;
							}
							if (isOutsideScreen(star)) {
								handleOffScreen(star);
							}
						}
					}
				}
			}
			function moveStart(stars, forces) {
				for (var f in forces) {
					var force = forces[f];
					for (var i in stars) {
						var star = stars[i];
						var d = dist(star.pos, force.pos);
						var forceReach = force.strength * FORCE_DIST;
						if (d < forceReach) {
							var pull = force.strength * (forceReach - d) / forceReach;
							var magnitude = norm(force.vect);
							var unitVect = vMulScalar(1/magnitude, force.vect);
							if (force.vect.x) {
								star.pos.x += pull * unitVect.x;
							}
							if (force.vect.y) {
								star.pos.y += pull * unitVect.y;
							}
							if (isOutsideScreen(star)) {
								handleOffScreen(star);
							}
						}
					}
				}
			}
			// =off screen=
			function wrap(star) {
				if (star.pos.x < 0) {
					star.pos.x = canvas.width;
				}
				if (star.pos.y < 0) {
					star.pos.y = canvas.height;
				}
				if (star.pos.x > canvas.width) {
					star.pos.x = 0;
				}
				if (star.pos.y > canvas.height) {
					star.pos.y = 0;
				}
			}
			function randomizePos(star) {
				star.pos.x = Math.random() * canvas.width;
				star.pos.y = Math.random() * canvas.height;
			}
			function randomFadeIn(star) {
				randomizePos(star);
				star.brightness = 0;
			}
			function dist(pos1, pos2) {
				return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
			}
			// http://geomalgorithms.com/a02-_lines.html
			function distPointToSegment(point, segStart, segEnd) {
				var v = sub(segEnd, segStart);
				var w = sub(point, segStart);
				var c1 = dot(w,v);
				if (c1 <= 0) {
					return vDist(point, segStart);
				}
				var c2 = dot(v,v);
				if (c2 <= c1) {
					return vDist(point, segEnd);
				}
				var b = c1 / c2;
				var pointB = add(segStart, vMulScalar(b, v));
				return vDist(point, pointB);
			}
			// =Helper functions=
			function dot(a, b) {
				return a.x * b.x + a.y * b.y;
			}
			function norm(v) {
				return Math.sqrt(dot(v,v));
			}
			function vDist(p1, p2) {
				return norm(sub(p1, p2));
			}
			function add(a, b) {
				return {x: a.x + b.x, y: a.y + b.y};
			}
			function sub(a, b) {
				return {x: a.x - b.x, y: a.y - b.y};
			}
			function vMulScalar(s, v) {
				return {x: v.x * s, y: v.y * s};
			}
			function eq(a, b) {
				return a.x == b.x && a.y == b.y;
			}
			//	=start=
			;(function() {
				if (ANIMATION_FRAME && window.requestAnimationFrame) {
					tick();
				} else {
					ANIMATION_FRAME = false;
					setInterval(tick, SPEED);
				}
			})();
		</script>
	</body>
</html>
