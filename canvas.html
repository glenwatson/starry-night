<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
		<title>Stars</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}
			body {
				background-color: #000000
			}
			canvas {
				position: absolute;
				left: 0;
				top: 0;
			}
			#settings {
				position: absolute;
				right: 0;
				bottom: 0;
			}
		</style>
	</head>
	<body>
		<canvas id="space">No canvas support</canvas>
		<div id="settings">
			<input onclick="DEBUG =! DEBUG;" type="checkbox" />
			<input onclick="CLEAR_ON_DRAW =! CLEAR_ON_DRAW;" type="checkbox" />
			<input onclick="forces=[];" type="checkbox" />
		</div>
		<script>
			// =settings=
			var ANIMATION_FRAME = true;
			var SPEED = 1; // only used if ANIMATION_FRAME == false
			var NUM_STARS = 1000;
			var FORCE_DIST = 40;
			var DEBUG = false;
			var CLEAR_ON_DRAW = true;
			// =template methods=
			var noop = function(){};
			var handleOffScreen = randomFadeIn; //randomizePos; //wrap;
			var getInitPos = resetOrigPos; //xSpreadPos; //randomPos;
			var getInitColor = randomColor; //rainbowColor;
			var recolor = recolorPos;
			var moveStars = moveStart; //moveLength;
			
			var canvas = document.getElementById('space');
			canvas.width = document.body.clientWidth;
			canvas.height = document.body.clientHeight;
			var ctx = canvas.getContext('2d');
			ctx.font = "8pt Arial";
			ctx.textAlign = "end";
			
			var stars = [];
			var forces = [];
			//populate
			for (var i=0; i<NUM_STARS; i++) {
				var star = {};
				star.pos = getInitPos(i, NUM_STARS);
				star.color = getInitColor(i, NUM_STARS, star);
				stars.push(star);
			}
			
			// =mouse clicks=
			;(function() {
				var mouseDownPoint={x:0, y:0};
				canvas.onmousedown = function (e) {
					if (e.which == 1) {
						mouseDownPoint = {x: e.clientX, y: e.clientY};
					}
				}
				canvas.onmouseup = function (e) {
					if (e.which == 1) {
						var mouseUpPoint = {x: e.clientX, y: e.clientY};
						if (!eq(mouseDownPoint, mouseUpPoint)) {
							forces.push({
								pos: mouseDownPoint, 
								vect: sub(mouseUpPoint, mouseDownPoint), 
								strength: Math.random() * 5 + 3
							});
						}
					}
				}
			})();
			
			//=start=
			;(function() {
				if (ANIMATION_FRAME && window.requestAnimationFrame) {
					tick();
				} else {
					ANIMATION_FRAME = false;
					setInterval(tick, SPEED);
				}
			})();
			
			function tick() {
				moveStars(stars, forces);
				if (recolor) {
					for (var i in stars) {
						stars[i].color = recolor(i, NUM_STARS, stars[i]);
					}
				}
				if (CLEAR_ON_DRAW) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
				drawStars(stars);
				if (DEBUG) {
					drawForces(forces);
					drawFramerate();
					drawFps();
				}
				if (ANIMATION_FRAME) {
					requestAnimationFrame(tick);
				}
			}
			
			// ==rendering==
			function drawStars(stars) {
				for (var i in stars) {
					ctx.fillStyle = stars[i].color;
					drawStar(stars[i].pos.x, stars[i].pos.y, ctx);
				}
			}
			function drawStar(x, y, ctx) {
				ctx.beginPath();
				ctx.arc(x, y, 2, 0, Math.PI*2, true);
				ctx.fill();
				ctx.closePath();
			}
			function drawForces(forces) {
				ctx.strokeStyle = "#ffffff";
				for (var i in forces) {
					drawForce(forces[i], ctx);
				}
			}
			function drawForce(force, ctx) {
				ctx.lineWidth = force.strength/5;
				ctx.beginPath();
				ctx.moveTo(force.pos.x, force.pos.y);
				ctx.lineTo(force.pos.x+force.vect.x, force.pos.y+force.vect.y);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(force.pos.x+force.vect.x, force.pos.y+force.vect.y, force.strength*2, 0, Math.PI*2, true);
				ctx.stroke();
			}
			// =fps=
			var drawFps = (function() {
				var fps = 0;
				var frameCount = 0;
				setInterval(function() {
					fps = frameCount;
					frameCount = 0;
				}, 1000); //1 second
				return function() {
					frameCount++;
					ctx.fillStyle = "#ffffff";
					ctx.fillText(fps+" fps", canvas.width-10, 20);
				}
			})();
			
			// =framerate=
			var drawFramerate = (function() {
				var lastFrame = new Date().getTime();
				return function() {
					var thisFrame = new Date().getTime();
					ctx.fillStyle = "#ffffff";
					ctx.fillText((thisFrame - lastFrame) / 1000, canvas.width-10, 10);
					lastFrame = thisFrame;
				}
			})();
			// =pos=
			function randomPos() {
				return {
					x: Math.random() * canvas.width,
					y: Math.random() * canvas.height,
				};
			}
			function xSpreadPos(i, totalCount) {
				return {
					x: (i / totalCount) * canvas.width,
					y: Math.random() * canvas.height,
				};
			}
			function gridPos(i, totalCount) {
				var val = i / totalCount * canvas.width * canvas.height;
				return {
					x: val % canvas.width,
					y: val / canvas.height,
				};
			}
			function resetOrigPos() {
				var pos = randomPos();
				pos.xOrig = pos.x;
				pos.yOrig = pos.y;
				return pos;
			}
			// =color=
			function randomColor() {
				return "#"+Math.round(Math.random() * Math.pow(16, 6)).toString(16);
			}
			function rainbowColor(i, total) {
				return "hsl("+(i / total * 360)+", 100%, 50%)";
			}
			function recolorPos(i, total, star) {
				return "hsl("+huePos(star)+", 100%, "+lightnessSparkle(star)+"%)";
			}
			function huePos(star) {
				return star.pos.x / canvas.width * 360;
			}
			function lightnessSparkle(star) {
				var OSCILLATION_SPEED =  0.02;
				if (typeof star.brightness == 'undefined') {
					star.brightness = Math.random() * Math.PI;
				} else if (star.brightness > Math.PI) {
					star.brightness = 0;
					star.pos.x = star.pos.xOrig;
					star.pos.y = star.pos.yOrig;
				} else {
					star.brightness += OSCILLATION_SPEED;
				}
				return Math.round(Math.sin(star.brightness)*90);
			}
			function isOutsideScreen(star) {
				return star.pos.x < 0 || star.pos.y < 0 ||
					star.pos.x > canvas.width || star.pos.y > canvas.height;
			}
			// ==Movement==
			function moveLength(stars, forces) {
				for (var f in forces) {
					var force = forces[f];
					var forceEnd = add(force.pos, force.vect);
					for (var i in stars) {
						var star = stars[i];
						var d = distPointToSegment(star.pos, force.pos, forceEnd);
						var forceReach = force.strength * FORCE_DIST;
						if (d < forceReach) {
							var pull = force.strength * (forceReach - d) / forceReach;
							var magnitude = norm(force.vect);
							var unitVect = vMulScalar(1/magnitude, force.vect);
							if (force.vect.x) {
								star.pos.x += pull * unitVect.x;
							}
							if (force.vect.y) {
								star.pos.y += pull * unitVect.y;
							}
							if (isOutsideScreen(star)) {
								handleOffScreen(star);
							}
						}
					}
				}
			}
			function moveStart(stars, forces) {
				for (var f in forces) {
					var force = forces[f];
					for (var i in stars) {
						var star = stars[i];
						var d = dist(star.pos, force.pos);
						var forceReach = force.strength * FORCE_DIST;
						if (d < forceReach) {
							var pull = force.strength * (forceReach - d) / forceReach;
							var magnitude = norm(force.vect);
							var unitVect = vMulScalar(1/magnitude, force.vect);
							if (force.vect.x) {
								star.pos.x += pull * unitVect.x;
							}
							if (force.vect.y) {
								star.pos.y += pull * unitVect.y;
							}
							if (isOutsideScreen(star)) {
								handleOffScreen(star);
							}
						}
					}
				}
			}
			// =off screen=
			function wrap(star) {
				if (star.pos.x < 0) {
					star.pos.x = canvas.width;
				}
				if (star.pos.y < 0) {
					star.pos.y = canvas.height;
				}
				if (star.pos.x > canvas.width) {
					star.pos.x = 0;
				}
				if (star.pos.y > canvas.height) {
					star.pos.y = 0;
				}
			}
			function randomizePos(star) {
				star.pos.x = Math.random() * canvas.width;
				star.pos.y = Math.random() * canvas.height;
			}
			function randomFadeIn(star) {
				randomizePos(star);
				star.brightness = 0;
			}
			function dist(pos1, pos2) {
				return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
			}
			// http://geomalgorithms.com/a02-_lines.html
			function distPointToSegment(point, segStart, segEnd) {
				var v = sub(segEnd, segStart);
				var w = sub(point, segStart);
				var c1 = dot(w,v);
				if (c1 <= 0) {
					return vDist(point, segStart);
				}
				var c2 = dot(v,v);
				if (c2 <= c1) {
					return vDist(point, segEnd);
				}
				var b = c1 / c2;
				var pointB = add(segStart, vMulScalar(b, v));
				return vDist(point, pointB);
			}
			// =Helper functions=
			function dot(a, b) {
				return a.x * b.x + a.y * b.y;
			}
			function norm(v) {
				return Math.sqrt(dot(v,v));
			}
			function vDist(p1, p2) {
				return norm(sub(p1, p2));
			}
			function add(a, b) {
				return {x: a.x + b.x, y: a.y + b.y};
			}
			function sub(a, b) {
				return {x: a.x - b.x, y: a.y - b.y};
			}
			function vMulScalar(s, v) {
				return {x: v.x * s, y: v.y * s};
			}
			function eq(a, b) {
				return a.x == b.x && a.y == b.y;
			}
		</script>
	</body>
</html>
